name: 'SAP CPI CI/CD Workflow'

on:
  workflow_dispatch:
    inputs:
      package_id:
        description: 'Enter Integration Package ID'
        required: true
        default: 'HelloWorldiFlow'

permissions:
  contents: write

jobs:
  fetch-and-commit:
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.commit_push.outputs.commit_sha }}
      artifact_matrix: ${{ steps.set_matrix.outputs.matrix }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq unzip

      - name: Get OAuth Token
        id: get_token
        run: |
          response=$(curl -s -X POST "$OAUTH_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=client_credentials&client_id=$OAUTH_CLIENT_ID&client_secret=$OAUTH_CLIENT_SECRET")
          token=$(echo "$response" | jq -r '.access_token')
          echo "::add-mask::$token"
          echo "access_token=$token" >> $GITHUB_OUTPUT
        env:
          OAUTH_CLIENT_ID:      ${{ secrets.OAUTH_CLIENT_ID }}
          OAUTH_CLIENT_SECRET:  ${{ secrets.OAUTH_CLIENT_SECRET }}
          OAUTH_TOKEN_URL:      ${{ secrets.OAUTH_TOKEN_URL }}

      - name: Fetch Artifacts Metadata JSON
        id: fetch_artifacts
        run: |
          token="${{ steps.get_token.outputs.access_token }}"
          pkg="${{ github.event.inputs.package_id }}"
          curl -s -X GET "${{ secrets.CPI_API_BASE_URL }}/IntegrationPackages('$pkg')/IntegrationDesigntimeArtifacts" \
            -H "Authorization: Bearer $token" \
            -H "Accept: application/json" > artifacts.json

      - name: Parse Artifact Metadata to Matrix
        id: set_matrix
        run: |
          matrix=$(jq -c '[.d.results[] | {id: .Id, version: .Version}]' artifacts.json)
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

      - name: Download & Unpack New Versions Only
        id: download_artifacts
        run: |
          set -euo pipefail
          token="${{ steps.get_token.outputs.access_token }}"
          pkg="${{ github.event.inputs.package_id }}"
          changed=false

          # we no longer keep zips separately; each zip lives next to its unpacked folder

          while read -r row; do
            id=$(echo "$row" | jq -r '.Id')
            ver=$(echo "$row" | jq -r '.Version')

            base_dir="packages/$pkg/iflows/$id/$ver"
            zip_path="$base_dir/${id}_${ver}.zip"
            tmp_zip="temp_${id}_${ver}.zip"

            # if already unpacked (zip exists & folder contains content), skip
            if [[ -d "$base_dir" && -f "$zip_path" ]]; then
              echo "$id v$ver already present — skipping."
              continue
            fi

            echo "Downloading new $id version $ver…"
            mkdir -p "$base_dir"
            curl -s -X GET "${{ secrets.CPI_API_BASE_URL }}/IntegrationDesigntimeArtifacts(Id='${id}',Version='${ver}')/\$value" \
              -H "Authorization: Bearer $token" -o "$tmp_zip"

            echo "Saving ZIP and unpacking to $base_dir…"
            mv "$tmp_zip" "$zip_path"

            # remove any previous content
            find "$base_dir" -mindepth 1 ! -name "${id}_${ver}.zip" -exec rm -rf {} +

            # unzip into same folder (preserves zip)
            unzip -qX "$zip_path" -d "$base_dir"

            # normalize .prop files
            find "$base_dir" -type f -name '*.prop' -exec sed -i '/^#/d' {} +
            find "$base_dir" -type f -name '*.prop' -exec sed -i '1i# autogenerated' {} +

            changed=true
          done < <(jq -c '.d.results[]' artifacts.json)

          echo "changed=$changed" >> $GITHUB_ENV

      - name: Commit & Push Changes (if any)
        id: commit_push
        run: |
          #!/usr/bin/env bash
          if [[ "${changed:-false}" != "true" ]]; then
            echo "No new versions or code changes — skipping commit."
            echo "commit_sha=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "New artifacts detected — committing…"
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add packages/
          git commit -m "Sync CPI artifacts for ${{ github.event.inputs.package_id }}"
          git pull --rebase
          git push origin HEAD:${{ github.ref_name }}

          echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

  deploy-artifact:
    needs: fetch-and-commit
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.fetch-and-commit.outputs.artifact_matrix) }}
    name: Deploy ${{ matrix.id }}-v${{ matrix.version }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Get OAuth Token
        id: get_token
        run: |
          response=$(curl -s -X POST "$OAUTH_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=client_credentials&client_id=$OAUTH_CLIENT_ID&client_secret=$OAUTH_CLIENT_SECRET")
          token=$(echo "$response" | jq -r '.access_token')
          echo "::add-mask::$token"
          echo "access_token=$token" >> $GITHUB_OUTPUT
        env:
          OAUTH_CLIENT_ID:      ${{ secrets.OAUTH_CLIENT_ID }}
          OAUTH_CLIENT_SECRET:  ${{ secrets.OAUTH_CLIENT_SECRET }}
          OAUTH_TOKEN_URL:      ${{ secrets.OAUTH_TOKEN_URL }}

      - name: Deploy Artifact
        run: |
          id="${{ matrix.id }}"
          version="${{ matrix.version }}"
          token="${{ steps.get_token.outputs.access_token }}"

          echo "Deploying $id v$version…"
          task_id=$(curl -s -X POST "${{ secrets.CPI_API_BASE_URL }}/DeployIntegrationDesigntimeArtifact?Id='${id}'&Version='${version}'" \
            -H "Authorization: Bearer $token" -H "Accept: application/json")
          echo "Deployment task ID: $task_id"

          if [[ -z "$task_id" || "$task_id" == "null" ]]; then
            echo "Failed to trigger deployment for $id"
            exit 1
          fi

          for attempt in {1..10}; do
            echo "Checking status for $id (attempt $attempt)…"
            status=$(curl -s -X GET "${{ secrets.CPI_API_BASE_URL }}/BuildAndDeployStatus(TaskId='${task_id}')" \
              -H "Authorization: Bearer $token" -H "Accept: application/json" \
              | jq -r '.d.Status // empty')
            if [[ "$status" == "SUCCESS" ]]; then
              echo "$id deployed"
              break
            elif [[ "$status" == "FAIL" ]]; then
              echo "$id deployment failed"
              exit 1
            else
              sleep 10
            fi
          done

          echo "Checking runtime for $id…"
          rt=$(curl -s -X GET "${{ secrets.CPI_API_BASE_URL }}/IntegrationRuntimeArtifacts('${id}')" \
            -H "Authorization: Bearer $token" -H "Accept: application/json" \
            | jq -r '.d.Status // empty')
          echo "Runtime status: $rt"
          if [[ "$rt" != "STARTED" ]]; then
            echo "$id did not start"
            exit 1
          fi
          echo "$id is running"

  rollback-if-failed:
    needs: deploy-artifact
    if: ${{ always() && contains(needs.deploy-artifact.result, 'failure') }}
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Rollback
        run: |
          echo "Some artifacts failed — rolling back…"

  tag-release:
    needs: deploy-artifact
    if: ${{ success() }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Tag new release
        run: |
          tag="v$(date +'%Y.%m.%d.%H%M')"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$tag" -m "Deployed all artifacts on $tag"
          git push origin "$tag"
